(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactHookForm = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  const STORE_DEFAULT_NAME = '__STATE_MACHINE__';
  const STATE_MACHINE_DEBUG_NAME = '___STATE_MACHINE_DEBUG__';

  var getBrowserStoreData = (storageType, storeName) => {
      const sessionStorageData = storageType.getItem(storeName);
      try {
          return sessionStorageData ? JSON.parse(sessionStorageData) : undefined;
      }
      catch (_a) {
          return undefined;
      }
  };

  function storeFactory(storageType, name) {
      const storeName = name || STORE_DEFAULT_NAME;
      let store = getBrowserStoreData(storageType, storeName);
      const getName = () => storeName;
      const set = (value) => {
          store = value;
      };
      const get = () => store;
      return {
          set,
          get,
          getName,
      };
  }

  var isUndefined = (val) => val === undefined;

  function setUpDevTools(isDevMode, storageType, getName, getStore) {
      if (typeof window === 'undefined' || !isDevMode)
          return;
      // @ts-ignore
      window.STATE_MACHINE_DEBUG = (value) => storageType.setItem(STATE_MACHINE_DEBUG_NAME, value);
      // @ts-ignore
      window.STATE_MACHINE_RESET = () => storageType.clear();
      // @ts-ignore
      window.STATE_MACHINE_GET_STORE = () => storageType.getItem(getName());
      // @ts-ignore
      window.STATE_MACHINE_SAVE_TO = name => window.localStorage.setItem(name, JSON.stringify(getStore()));
      // @ts-ignore
      window.STATE_MACHINE_LOAD = ({ storeName, data, }) => storageType.setItem(getName() || STATE_MACHINE_DEBUG_NAME, data || window.localStorage.getItem(storeName) || '');
  }

  var StateMachineContext = React.createContext({
      store: {},
      updateStore: (payload) => payload,
  });

  var transformStore = ({ transform, externalStoreName, storageType, store, }) => transform({
      externalStoreData: getBrowserStoreData(storageType, externalStoreName),
      currentStoreData: store,
  });

  function getSyncStoreData(defaultStoreData, options, storageType) {
      let store = defaultStoreData;
      const syncStoreOption = options.syncStores;
      if (!syncStoreOption)
          return store;
      try {
          if (Array.isArray(syncStoreOption)) {
              syncStoreOption.forEach(option => {
                  store = transformStore({
                      transform: option.transform,
                      externalStoreName: option.externalStoreName,
                      storageType,
                      store,
                  });
              });
          }
          else if (syncStoreOption.externalStoreName &&
              typeof syncStoreOption.transform === 'function' &&
              typeof syncStoreOption.externalStoreName === 'string') {
              return transformStore({
                  transform: syncStoreOption.transform,
                  externalStoreName: syncStoreOption.externalStoreName,
                  storageType,
                  store,
              });
          }
          else {
              Object.entries(syncStoreOption).forEach(([key, values]) => {
                  const browserStore = getBrowserStoreData(storageType, key);
                  values.forEach((value) => {
                      store = Object.assign(Object.assign({}, store), {
                          [value]: Object.assign(Object.assign({}, store[value]), browserStore[value]),
                      });
                  });
              });
          }
      }
      catch (_a) {
          return store;
      }
      return store;
  }

  const isClient = typeof window !== 'undefined';
  const isDevMode = "production" !== 'production';
  let storageType = isClient
      ? window.sessionStorage
      : {
          getItem: payload => payload,
          setItem: (payload) => payload,
          clear: () => { },
          length: 0,
          key: (payload) => payload.toString(),
          removeItem: () => { },
      };
  let getStore;
  let setStore;
  let getName;
  let middleWaresArray = [];
  function setStorageType(type) {
      storageType = type;
  }
  function createStore(defaultStoreData, options = {
      name: STORE_DEFAULT_NAME,
      middleWares: [],
      syncStores: undefined,
  }) {
      const storeName = options ? options.name : STORE_DEFAULT_NAME;
      const methods = storeFactory(storageType, storeName);
      getName = methods.getName;
      getStore = methods.get;
      setStore = methods.set;
      middleWaresArray = options.middleWares;
      setUpDevTools(isDevMode, storageType, getName, getStore);
      setStore(getSyncStoreData(getStore() || defaultStoreData, options, storageType));
  }
  function StateMachineProvider(props) {
      const [globalState, updateStore] = React.useState(getStore());
      const value = React.useMemo(() => ({
          store: globalState,
          updateStore,
      }), [globalState]);
      // @ts-ignore
      return React.createElement(StateMachineContext.Provider, Object.assign({ value: value }, props));
  }
  const actionTemplate = ({ options, callback, updateStore, }) => (payload) => {
      let result;
      const debugName = callback ? callback.name : '';
      if (callback) {
          result = callback(getStore(), payload);
      }
      setStore(isUndefined(result) ? getStore() : result);
      storageType.setItem(getName(), JSON.stringify(getStore()));
      if (isUndefined(options) ||
          (options && options.shouldReRenderApp !== false)) {
          let pipeData = getStore();
          if (Array.isArray(middleWaresArray) && middleWaresArray.length) {
              pipeData = middleWaresArray.reduce((currentValue, currentFunction) => currentFunction(currentValue) || currentValue, pipeData);
          }
          updateStore(pipeData);
      }
  };
  function useStateMachine(updateStoreFunction, options) {
      const { store: globalState, updateStore } = React.useContext(StateMachineContext);
      if (updateStoreFunction && Object.keys(updateStoreFunction).length) {
          return {
              actions: Object.entries(updateStoreFunction).reduce((previous, [key, callback]) => (Object.assign(Object.assign({}, previous), { [key]: React.useCallback(actionTemplate({
                      options,
                      callback,
                      updateStore,
                  }), []) })), {}),
              action: p => p,
              state: globalState,
          };
      }
      return {
          actions: {},
          action: React.useCallback(updateStoreFunction
              ? actionTemplate({
                  options,
                  callback: updateStoreFunction,
                  updateStore,
              })
              : () => { }, []),
          state: globalState,
      };
  }

  exports.StateMachineContext = StateMachineContext;
  exports.StateMachineProvider = StateMachineProvider;
  exports.createStore = createStore;
  exports.setStorageType = setStorageType;
  exports.useStateMachine = useStateMachine;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
